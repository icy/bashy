#!/bin/bash

# Purpose: Docker utils
# Author : Anh K. Huynh
# Date   : 2015 May 04th
# Ref.   : Feature request at https://github.com/docker/docker/issues/12791

# Return IP address of a docker container
# Input : $1: Docker container ID / name
# Output: The IP address
docker_to_ip() {
  docker inspect --format='{{.NetworkSettings.IPAddress}}' $1
}

# PRINT OUT
#   the core rules for NAT-network generated by Docker
docker_nat_core_rules() {
  cat <<-EOF
  iptables -t nat -N DOCKER \\
  && iptables -N DOCKER \\
  && {
    iptables -t nat -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
    iptables -t nat -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
    iptables -t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

    iptables -A FORWARD -o docker0 -j DOCKER
    iptables -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -i docker0 ! -o docker0 -j ACCEPT
    iptables -A FORWARD -i docker0 -o docker0 -j ACCEPT
  } \\
  || true
EOF
}

# Return iptables (NAT) rules for a running container
# Input : Container ID/Name
# Output: iptables commands
#
# FIXME: This script will expose a security hole. By default,
# FIXME: Docker packets are filtered with DOCKER and we don't
# FIXME: have any limitation on that. By using this script,
# FIXME: the port may be accessible by the world. Please make sure
# FIXME: to have another firewall layer. Don't use this script bindly
# FIXME: when you are using Digital Ocean networks.
#
docker_container_to_nat() {
  local _ip=
  local _id="${1:-xxx}"

  _ip="$(docker_to_ip $_id)"
  [[ $? -eq 0 ]] || return $?


  # $ docker port test
  # 80/tcp -> 127.0.1.1:1234
  # 80/tcp -> 0.0.0.0:1235
  docker port $_id \
  | grep /tcp \
  | sed -e 's#[/tcp>: -]\+# #g' \
  | awk \
      -vIP=$_ip \
      -vCONTAINER_ID=$_id \
      '{
        iport = $1
        eip   = $2
        eport = $3

        printf("iptables -t nat -C POSTROUTING -s %s/32 -d %s/32 -p tcp -m tcp --dport %s -j MASQUERADE 2>/dev/null \\\n", IP, IP, iport);
        printf("|| iptables -t nat -A POSTROUTING -s %s/32 -d %s/32 -p tcp -m tcp --dport %s -j MASQUERADE\n", IP, IP, iport);

        printf("iptables -t nat -C DOCKER -d %s/32 ! -i docker0 -p tcp -m tcp --dport %s -j DNAT --to-destination %s:%s 2>/dev/null \\\n", eip, eport, IP, iport);
        printf("|| iptables -t nat -A DOCKER -d %s/32 ! -i docker0 -p tcp -m tcp --dport %s -j DNAT --to-destination %s:%s\n", eip, eport, IP, iport);

        printf("iptables -C DOCKER -d %s/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport %s -j ACCEPT 2>/dev/null \\\n", IP, iport);
        printf("|| iptables -A DOCKER -d %s/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport %s -j ACCEPT\n", IP, iport);
      }'
}

# Return iptables (NAT) rules for all running containers
# Input : NONE
# Output: all iptables rules for running container
docker_containers_to_nat() {
  while read CONTAINER_ID; do
    echo >&2 ":: docker/firewall: Generating rule for $CONTAINER_ID..."
    docker_container_to_nat $CONTAINER_ID
  done < <(docker ps -q)
}

docker_images_clean() {
  docker rmi -f \
    $(docker images \
    | grep '^<none' \
    | awk '{print $3}')
}

# Return uptime of a container in minutes
# $1: container id
# If `$1` is missing, return system uptime
# NOTE: accessing to /proc/ is required.
docker_uptime() {
  local _pid="1"

  if [[ -n "${1:-}" ]]; then
    _pid="$(docker inspect --format='{{.State.Pid}}' "$1" 2>/dev/null)"
  fi
  if [[ -z "$_pid" || "$_pid" == 0 ]]; then
    echo 0
    return
  fi

  ps h -oetime "$_pid" \
  | awk '{ match($0, /([0-9]+-)?(([0-9]+):)?([0-9]+):([0-9]+)/, m); printf("%d\n", (m[1]*24 + m[3])*60 + m[4] + m[5]/60); }'
}
